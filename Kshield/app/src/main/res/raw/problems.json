{
  "subpages": [
    {
      "subpage": 1,
      "levels": [
        {
          "level": 1,
          "images" : ["level1_system_img1","level1_system_img2"],
          "codeBox" : "이 코드는 기본적인 액세스 제어와 권한 관리를 구현한 프로그램입니다. 권한 관리 시스템에서 사용자의 역할에 따라 접근 권한을 결정하는 메커니즘을 제공합니다. 다음은 코드의 주요 부분에 대한 설명입니다:\n\n1.\t사용자 등록 및 역할 할당 (add_user):\n-\tadd_user 함수는 사용자에게 역할을 할당하는 역할을 합니다. 사용자는 딕셔너리 user_roies에 역할과 함께 저장됩니다.\n\n2.\t역할 관리 (add_role):\n-\tadd_role 함수는 새로운 역할을 시스템에 추가합니다. 역할이 이미 존재하는 경우에는 “Role already exists.”라는 메시지가 출력됩니다.\n\n3.\t권한 할당 (assign_permission):\n-\tassign_permission 함수는 특정 역할에 권한을 추가하는 기능을 합니다. 이 함수는 먼저 역할이 존재하는 지 확인한 후, 해당 역할에 권한을 부여합니다.\n\n4.\t액세스 확인 (check_access):\n-\t사용자가 특정 권한을 가지고 있는지 확인하는 기능을 합니다. 사용자가 등록된 역할에 해당 권한이 있을 경우 액세스를 허용하고, 그렇지 않으면 거부합니다. \n\n5.\t권한 나열 (list_permissions):\n-\t역할에 할당된 모든 권한을 반환하는 함수입니다. 역할이 존재하지 않는 경우에는 존재하지 않는 역할임을 알리는 메시지를 출력합니다.\n\n이 프로그램은 권한 기반 액세스 제어(RBAC)를 구현하여 보안 시스템에서 중요한 역할을 수행합니다. 역할에 권한을 할당하고, 사용자에게 역할을 배정함으로써 사용자별로 권한을 효율적으로 관리할 수 있습니다.\n",
          "problems": [
            {
              "question": "1. 파일의 무결성을 확인하기 위해 사용되는 해시 알고리즘은 무엇인가요?",
              "choices": ["MD5", "SHA-1", "SHA-256", "AES-256"],
              "correctAnswer": 2,
              "commentary": "코드의 calculate_hash 함수에서 hashlib.sha256() 을 사용하여 SHA-256 해시 알고리즘으로 파일의 무결성을 검사합니다."
            },
            {
              "question": "2. calculate_hash 함수에서 파일을 처리할 때 사용되는 방식은 무엇인가요?",
              "choices": ["파일을 한 번에 모두 읽어 처리한다.", "파일을 1024바이트씩 읽어 처리한다.", "파일을 4096바이트씩 읽어 처리한다.", "파일을 바이트 단위로 읽어 처리한다."],
              "correctAnswer": 2,
              "commentary" : "calculate_hash 함수는 파일을 4096바이트씩 읽어 처리하며, 해시 값을 점진적으로 업데이트합니다."
            },
            {
              "question": "3. 파일이 수정되었는지 확인하기 위해 사용되는 방법은 무엇인가요?",
              "choices": ["파일의 크기를 비교한다.", "파일의 마지막 수정 시간을 비교한다.", "파일의 이름을 비교한다.", "파일의 해시 값을 비교한다."],
              "correctAnswer": 3,
              "commentary" : "코드에서 check_integrity 함수는 저장된 파일의 해시값과 현재 파일의 해시 값을 비교하여 파일이 수정되었는지 확인합니다."
            },
            {
              "question": "4. 만약 파일이 삭제된 경우, 프로그램의 동작은 어떻게 될까요?",
              "choices": ["오류를 발생시킨다.", "무시하고 넘어간다.", "삭제된 파일에 대한 메시지를 출력한다.", "새로운 파일로 대체한다."],
              "correctAnswer": 2,
              "commentary" : "코드에서 check_integrity 함수는 파일이 존재하지 않을 경우 \"File [파일 경로] has been deleted!\" 메시지를 출력합니다."
            },
            {
              "question": "5. 디렉토리 내의 파일들에 대해 해시 값을 생성하고 저장하는 함수는 무엇인가요?",
              "choices": ["calculate_hash", "generate_file_hashes", "check_integrity", "store_hashes"],
              "correctAnswer": 1,
              "commentary" : ": generate_file_hashes 함수는 디렉토리 내의 모든 파일에 대해 해시값을 계산하고, 이를 저장하는 역할을 합니다."
            }
          ]
        },
        {
          "level": 2,
          "images" : ["level2_system_img1","level2_system_img2"],
          "codeBox" : "이 코드는 사용자 인증 시스템을 구현한 것으로, 비밀번호를 해시 처리하고 인증하는 방식입니다. 시스템 보안에서 비밀번호를 안전하게 저장하고 사용자를 인증하는 것은 매우 중요하며, 이 프로그램은 솔트(salt)를 사용한 비밀번호 해싱과 검증을 통해 안전성을 제공합니다. 주요 부분은 다음과 같습니다.\n\n1.\t솔트 생성 (create_salt):\n-\tOs.urandom(16)을 사용하여 16바이트 크기의 랜덤 솔트를 생성합니다. 솔트는 해싱 전 비밀번호에 추가되어 해시 값의 유일성으 보장합니다.\n\n2.\t비밀번호 해시 생성 (hash_password):\n-\t비밀번호와 솔트를 결합해 PBKDF2-HMAC-SHA256 해시 알고리즘으로 해시 값을 생성합니다. 해싱 과정은 100,000번 반복되어 해시 계산을 더욱 복잡하게 만듭니다.\n\n3.\t사용자 등록 (register_user):\n-\t사용자는 비밀번호와 함께 등록되며, 비밀번호는 평문이 아닌 솔트와 결합된 해시 값으로 저장됩니다. 사용자 정보는 딕셔너리 user_db에 솔트와 해시 값으로 저장됩니다.\n\n4.\t사용자 인증 (authenticate_user):\n-\t인증 과정에서는 사용자가 입력한 비밀번호와 저장된 솔트를 다시 사용해 해시 값을 계산합니다. 저장된 해시 값과 새로 계산한 해시 값이 일치하면 인증에 성공하고, 일치하지 않으면 인증이 실패합니다. \n\n이 코드는 솔트 사용 및 반복적인 해시 생성 방식(PBKDF2)을 통해 단순한 해싱보다 더 안전하게 비밀번호를 보호하며, 이로 인해 해시된 비밀번호가 유출되더라도 공격자가 비밀번호를 쉽게 복원할 수 없도록 설계되었습니다.",
          "problems": [
            {
              "question": "1. 비밀번호 해싱에 사용되는 해시 알고리즘은 무엇인가요?",
              "choices": ["MD5", "SHA-1", "SHA-256", "PBKDF2-HMAC-SHA256"],
              "correctAnswer": 3,
              "commentary" : "코드에서 비밀번호 해싱에 사용되는 알고리즘은 hashlib.pbkdf2_hmac('sha256', …)으로, \n이는 PBKDF2-HMAC-SHA256 방식입니다. 이 방식은 비밀번호 해시를 더욱 안전하게 보호합니다."
            },
            {
              "question": "2. 솔트(salt)의 역할은 무엇인가요?",
              "choices": ["비밀번호를 암호화하는 데 사용되는 키이다.", "비밀번호 해시를 더욱 복잡하게 만들어 무차별 대입 공격을 방지한다.", "비밀번호를 평문으로 저장한다.", "사용자 이름을 암호화하는데 사용된다."],
              "correctAnswer": 1,
              "commentary" : "솔트(salt)는 비밀번호에 추가되어 해싱 전 비밀번호의 복잡성을 높여 동일한 비밀번호에 대해 다른 해시값이 생성되도록 하여 , 공격자가 사전 공격이나 무차별 대입 공격을 성공적으로 수행하는 것을 방지합니다."
            },
            {
              "question": "3. 비밀번호 해시는 몇 번의 반복을 통해 생성되나요?",
              "choices": ["10", "100", "1000", "100000"],
              "correctAnswer": 3,
              "commentary" : "코드에서 hashlib.pbkdf2_hmac 함수는 네 번째 인자로반복횟수를 받으며, 여기서 100,000번의 반복을 통해 비밀번호 해시를 생성합니다. 반복횟수가 많을수록 공격자가 해시를 역으로 추측하기 어려워집니다."
            },
            {
              "question": "4. register_user 함수가 성공적으로 사용자를 등록했을 때 반환하는 값은 무엇인가요?",
              "choices": ["None", "True", "False", "Username"],
              "correctAnswer": 1,
              "commentary" : ""
            },
            {
              "question": "5. 사용자가 인증되지 않았을 경우 authenticate_user 함수는 어떤 결과를 반환하나요?",
              "choices": ["Error", "None", "False", "True"],
              "correctAnswer": 2,
              "commentary" : "authenticate_user 함수는 사용자가 인증되지 않을 경우 False를 반환하며, 인증이 성공하면 True를 반환합니다."
            }
          ]
        },
        {
          "level": 3,
          "images" : ["level3_system_img1","level3_system_img2"],
          "codeBox": "이 코드는 파일 무결성 검사 및 침입 탐지 시스템을 구현한 것으로, 파일의 변경사항을 감지하여 로그에 기록합니다. 시스템은 다음과 같은 주요 기능을 수행합니다.\n\n1.\t파일 해시 생성 (calculate_hash):\n-\t주어진 파일의 해시 값을 계산합니다. 이 코드는 hashlib 모듈의 SHA-256 알고리즘을 사용하여 파일의 고유한 해시 값을 생성하고, 파일이 변경되었을 때 이를 탐지하는 데 사용됩니다.\n\n2.\t파일 추가 및 모니터링 (add_file):\n-\t주어진 파일을 모니터링 목록에 추가하고, 해당 파일의 초기 해시 값을 생성해 저장합니다. 이후 무결성 검사를 통해 파일이 변경되었는지 확인할 때 이 해시 값과 비교합니다.\n\n3.\t무결성 확인 (check_integrity):\n-\t모니터링 중인 파일의 현재 해시 값을 다시 계산하고, 저장된 해시 값과 비교하여 파일의 무결성을 확인합니다. 만약 값이 다르면 파일이 변경된 것으로 간주하고 침입합니다.",
          "problems": [
            {
              "question": "1. 이 코드의 주된 목적은 무엇인가요?",
              "choices": ["파일 압축 및 저장", "파일삭제 방지 시스템 구현", "파일의 무결성 검사 및 침입 탐지", "파일을 자동으로 백업하는 시스템"],
              "correctAnswer": 2,
              "commentary" : "이 코드는 파일의 해시값을 생성하여 파일의 무결성을 주기적으로 확인하고, 무결성이 깨진 경우(파일 변경) 이를 탐지하는데 중점을 두고 있습니다."
            },
            {
              "question": "2. 파일 무결성 확인 과정에서 check_integrity 함수는 무엇을 비교하나요?",
              "choices": ["파일의 크기와 초기 크기", "파일의 현재 해시값과 저장된 해시 값", "파일의 경로와 크기", "파일의 이름과 확장자"],
              "correctAnswer": 1,
              "commentary" : "check_integrity 함수는 파일의 현재 해시값을 다시 계산하고, 이 값이 저장된 초기 해시 값과 다른 경우 무결성 위반을 탐지하여 로그에 기록합니다."
            },
            {
              "question": "3. 로그 파일에 침입이 감지되었다는 메시지가 기록되는 상황은 무엇인가요?",
              "choices": ["파일이 추가되었을 때", "파일의 해시 값이 달라졌을 때", "파일이 읽기 전용으로 변경되었을 때", "파일의 이름이 변경되었을 때"],
              "correctAnswer": 1,
              "commentary" : "check_integrity 함수에서 파일의 현재 해시값이 저장된 해시값과 다를 경우 로그 파일에 무결성 위반 경고가 기록됩니다."
            },
            {
              "question": "4. 다음 중 이 코드가 침입을 탐지할 수 있는 상황은 무엇인가요?",
              "choices": ["파일의 내용이 변경되었을 때", "파일의 이름이 변경되었을 때", "파일이 이동되었을 때", "파일의 읽기 권한이 변경되었을 때"],
              "correctAnswer": 0,
              "commentary" : "이 코드는 파일의 해시값을 통해 파일 내용의 변경여부를 감지합니다. 따라서 파일의 내용이 변경되면 해시 값이 달라져 침입이 탐지됩니다."
            },
            {
              "question": "5. 이 코드의 주된 취약점 중 하나는 무엇일까요?",
              "choices": ["로그파일에 중요한 정보가 기록되지 않는다.", "파일을 읽는 동안 비정상적인 권한 변경이 탐지되지 않는다.", "해시 값을 생성하는데 사용하는 알고리즘이 오래된 MD5이다.", "파일의 크기만 확인하여 파일의 변경을 추적한다."],
              "correctAnswer": 1,
              "commentary" : "이 코드는 파일의 내용 변경을 탐지하기 위한 무결성 검사 시스템이므로, 파일 권한의 변경은 탐지하지 못합니다. 따라서 파일 권한 변경과 같은 공격이 발생할 경우 이를 탐지할 수 없습니다."
            }
          ]
        }

      ]
    },

    {
      "subpage": 2,
      "levels": [
        {
          "level": 1,
          "images": ["level1_web_img1", "level1_web_img2","level1_web_img3"],
          "codeBox": "이 코드는 SQL 인젝션 공격을 방지하면서도 사용자의 비밀번호를 안전하게 저장하고 인증하는 간단한 웹 애플리케이션 로그인 시스템을 구현한 예제입니다. 주요 기능을 설명하자면:\n\n1.\t데이터베이스 생성 및 연결:\n-\tuserAuthentication 클래스는 SQLite 데이베이스에 연결을 생성하고, create_table 메서드를 통해 유저 정보를 저장하는 테이블을 만듭니다.\n\n2.\t비밀번호 해시 처리:\n-\thash_password 메서드는 비밀번호를 SHA-256 해시 알고리즘으로 변환해 저장합니다. 비밀번호를 해시로 저장함으로써 데이터베이스가 유출되더라도 실제 비밀번호가 직접 노출되지 않도록 보호합니다.\n\n3.\t피라미터화된 쿼리를 통한 SQL 인젝션 방지:\n-\tLogin 메서드는 피라미터화된 쿼리(?)를 사용해 사용자 입력 값을 안전하게 처리함으로써 SQL 인젝션 공격을 방지합니다. 이를 통해 악의적인 사용자가 쿼리에 변조된 입력값을 삽입하는 것을 막을 수 있습니다.\n\n4.\t유저 추가:\n-\tadd_user 메서드는 새로운 사용자를 추가하는 역할을 하며, 비밀번호를 평문이 아닌 해시 값으로 저장해 보안성을 높입니다.\n\n5.\t보안 향상 가능성:\n-\t이 코드는 기본적인 보안을 제공하지만, 비밀번호 해시에 salt를 추가하면 보안성이 더 높아집니다. salt는 동일한 비밀번호라도 각기 다른 해시 값을 생성하여 무차별 대입 공격(브루트포스)과 레인보우 테이블 공격에 대한 방어력을 제공합니다.\n\n결론적으로, 이 시스템은 SQL 인젝션 방어와 비밀번호 해시화를 통해 기본적인 보안을 제공하지만, salt를 사용한 해시 강화 등 추가적인 보안 조치가 필요합니다.\n",
          "problems": [
            {
              "question": "1. 이 코드의 주된 보안 목적은 무엇인가요?",
              "choices": ["사용자가 여러 번 로그인할 수 있도록 허용하는 것", "사용자의 비밀번호를 안전하게 저장하고 SQL인젝션을 방지하는 것", "사용자의 로그 기록을 보관하는 것", "데이터베이스 연결을 최적화 하는 것"],
              "correctAnswer": 1,
              "commentary": "이 코드는 사용자의 비밀번호를 해시 값으로 저장하며, SQL 인젝션 공격을 방지하기 위해 파라미터화된 쿼리(? 및 execute 메서드)를 사용하고 있습니다."
            },

            {
              "question": "2. 이 코드에서 사용자의 비밀번호를 해시 처리하는데 사용되는 해시 알고리즘은 무엇일까요?",
              "choices": ["MD5", "SHA-1", "SHA-256", "Blowfish"],
              "correctAnswer": 2,
              "commentary": "hash_password 함수는 hashlib.sha256()을 사용하여 사용자의 비밀번호를 해시하고 있습니다. 이는 비교적 강력한 해시 알고리즘으로 간주합니다."
            },

            {
              "question": "3. 이 코드에서 SQL 인젝션 공격을 방지하기 위해 사용된 보안 기법은 무엇일까요?",
              "choices": ["데이터베이스 암호화", "사용자 입력 검증", "피라미터화 된 쿼리 사용", "입력 필터링"],
              "correctAnswer": 2,
              "commentary": "SQL 인젝션 공격을 방지하기 위해 파라미터화된 쿼리(? 기호를 사용하여 변수로 입력)를 적용하였으며, 이를 통해 사용자 입력을 안전하게 처리할 수 있습니다."
            },

            {
              "question": "4. 만약 SQL 인젝션 공격을 시도하려는 악의적인 사용자가 username 필드에 admin' OR '1'='1이라는 값을 입력하면, 어떤 결과가 나올까요?",
              "choices": ["모든 사용자가 로그인된다.", "쿼리가 실패하고 오류가 발생한다.", "'admin'사용자가 로그인된다.", "'admin'사용자의 비밀번호가 표시된다."],
              "correctAnswer": 1,
              "commentary": "파라미터화된 쿼리를 사용하기 때문에, 인젝션 공격 시도는 쿼리 문자열에 그대로 포함되지 않으며 안전하게 처리됩니다. ? 기호를 사용하여 입력값이 직접 바인딩되므로, 인젝션 공격이 실패합니다."
            },

            {
              "question": "5. 다음 중 이 코드의 개선점으로 올바른 것은 무엇인가요?",
              "choices": ["SHA-256 대신 MD5를 사용하여 비밀번호 해시를 처리해야 한다.", "비밀번호 해시와 함께 salt를 추가해 저장하는 것이 바람직하다.", "로그인 시 비밀번호가 평문으로 저장되어야 한다.", "비밀번호를 해시 처리하지 않고 암호화해야 한다."],
              "correctAnswer": 1,
              "commentary": "현재 코드에서는 비밀번호를 해시 처리하는 것만 적용했으나, 추가적인 보안 강화를 위해 salt 값을 사용해 해시를 생성하는 것이 바람직합니다. Salt는 동일한 비밀번호라도 각기 다른 해시 값을 생성하게 하여 무차별 대입 공격에 대한 방어를 강화합니다."
            }
          ]
        },

        {
          "level": 2,
          "images": ["level2_web_img1", "level2_web_img2"],
          "codeBox": "이 코드는 SQL 인젝션 공격을 방지하면서도 사용자의 비밀번호를 안전하게 저장하고 인증하는 간단한 웹 애플리케이션 로그인 시스템을 구현한 예제입니다. 주요 기능을 설명하자면:\n\n1.\t데이터베이스 생성 및 연결:\n-\tuserAuthentication 클래스는 SQLite 데이베이스에 연결을 생성하고, create_table 메서드를 통해 유저 정보를 저장하는 테이블을 만듭니다.\n\n2.\t비밀번호 해시 처리:\n-\thash_password 메서드는 비밀번호를 SHA-256 해시 알고리즘으로 변환해 저장합니다. 비밀번호를 해시로 저장함으로써 데이터베이스가 유출되더라도 실제 비밀번호가 직접 노출되지 않도록 보호합니다.\n\n3.\t피라미터화된 쿼리를 통한 SQL 인젝션 방지:\n-\tLogin 메서드는 피라미터화된 쿼리(?)를 사용해 사용자 입력 값을 안전하게 처리함으로써 SQL 인젝션 공격을 방지합니다. 이를 통해 악의적인 사용자가 쿼리에 변조된 입력값을 삽입하는 것을 막을 수 있습니다.\n\n4.\t유저 추가:\n-\tadd_user 메서드는 새로운 사용자를 추가하는 역할을 하며, 비밀번호를 평문이 아닌 해시 값으로 저장해 보안성을 높입니다.\n\n5.\t보안 향상 가능성:\n-\t이 코드는 기본적인 보안을 제공하지만, 비밀번호 해시에 salt를 추가하면 보안성이 더 높아집니다. salt는 동일한 비밀번호라도 각기 다른 해시 값을 생성하여 무차별 대입 공격(브루트포스)과 레인보우 테이블 공격에 대한 방어력을 제공합니다.\n\n결론적으로, 이 시스템은 SQL 인젝션 방어와 비밀번호 해시화를 통해 기본적인 보안을 제공하지만, salt를 사용한 해시 강화 등 추가적인 보안 조치가 필요합니다.\n",
          "problems": [
            {
              "question": "1. 이 코드의 주된 보안 취약점은 무엇인가요?",
              "choices": ["파일 경로 하드코딩", "SQL 인젝션 가능성", "파일 확장자 검증 미흡", "디렉토리 경로 탐색 취약점"],
              "correctAnswer": 3,
              "commentary": "이 코드에서 파일을 저장할 때, 파일 이름에 대한 별도의 유효성 검사가 없으므로 악의적인 사용자가 경로 탐색(Directory Traversal) 공격을 통해 서버의 다른 위치에 파일을 저장할 수 있는 가능성이 있습니다."
            },

            {
              "question": "2. 이 코드에서 파일 업로드가 안전하게 처리되기 위해 개선해야 할 부분은 무엇일까요?",
              "choices": ["파일 저장 경로를 하드코딩하는 대신 사용자 입력을 받도록 수정한다.", "업로드된 파일의 확장자만 확인하는 것이 아니라 실제 파일 내용도 검증한다.", "파일 이름에 슬래시(/)가 있는지 확인하고 허용하지 않는다.", "파일 업로드 기능을 제거한다."],
              "correctAnswer": 1,
              "commentary": "단순히 파일 확장자만 확인하는 것은 불충분하며, 파일 내용을 확인하여 실제 파일 형식이 올바른지 검증하는 작업이 필요합니다. 그렇지 않으면 악성 스크립트가 이미지 파일로 위장하여 업로드될 수 있습니다."
            },

            {
              "question": "3. 이 코드는 클라이언트로부터 파일을 업로드할 때, 허용되지 않은 확장자 파일을 업로드 할 경우 어떤 결과가 발생하는가?",
              "choices": ["서버가 파일을 무조건 저장한다.", "파일이 저장되지 않고, 'File type not allowed' 메시지를 반환한다.", "서버가 에러를 발생시키고 종료된다.", "파일이 저장되지 않고, 자동으로 삭제된다."],
              "correctAnswer": 1,
              "commentary": "allowed_file 함수에서 파일 확장자를 확인하여 허용되지 않는 파일 확장자인 경우 플래시 메시지로 'File type not allowed'를 출력하고 업로드를 중단합니다."
            },

            {
              "question": "4. 이 코드의 취약점을 통해 공격자가 악의적인 파일을 업로드할 수 있는 방식으로 올바른 것은 무엇인가요?",
              "choices": ["파일 확장자를 .jpg로 변경하고 악성 코드 파일을 업로드한다.", "서버에 있는 중요한 파일을 삭제하는 스크립트를 전송한다.", "사용자의 비밀번호를 탈취하는 SQL 인젝션 공격을 시도한다.", "파일을 업로드한 뒤 관리자 페이지에 접근한다."],
              "correctAnswer": 0,
              "commentary": "파일 확장자만 검증하고 실제 파일 내용을 확인하지 않기 때문에, 공격자는 악성 스크립트를 이미지 파일로 위장하여 .jpg 확장자를 사용해 업로드할 수 있습니다. 이런 상황에서는 서버 측에서 파일 내용을 확인해야 합니다."
            },

            {
              "question": "5. 이 코드에서 Flask 어플리케이션의 보안 설정을 강화하기 위한 방법으로 올바른 것은 무엇인가요?",
              "choices": ["debug=True 대신 debug=False로 변경", "업로드된 파일을 즉시 삭제", "모든 파일 형식을 허용", "사용자가 파일 경로를 직접 입력하도록 한다."],
              "correctAnswer": 0,
              "commentary": "debug=True 설정은 개발 환경에서만 사용해야 하며, 이를 False로 설정하지 않으면 잠재적인 보안 취약점이 노출될 수 있습니다. 또한 디버그 모드에서는 전체 에러 메시지가 외부에 공개될 위험이 있습니다."
            }
          ]
        },

        {
          "level": 3,
          "images": ["level3_web_img1", "level3_web_img2"],
          "codeBox": "이 코드는 기본적인 웹 애플리케이션을 구성하고 있으며, 로그인, 로그아웃, 세션 관리, 그리고 사용자 입력을 처리하는 검색 기능을 제공합니다. 그러나 보안 측면에서 여러 가지 취약점이 존재합니다.\n\n1.\t세션 관리 취약점: 세션 쿠키에 Secure와 SameSite 플래그가 설정되지 않아 세션 탈취(CSRF 공격 등) 및 중간자 공격의 위험이 있습니다.\n\n2.\tXSS 취약점: 검색 기능에서 사용자 입력을 HRML로 직접 출력하는 방식으로 처리하고 있어 크로스 사이트 스크립팅(XSS)공격에 취약합니다. 악의적인 사용자가 자바스크립트 코드를 삽입할 수 있습니다.\n\n3.\tSHA-256 사용의 문제점: SHA-256은 안전한 해시 함수이지만, 패스워드 해싱에 솔트를 사용하지 않으면 레인보우 테이블 공격에 취약합니다. 솔트는 각 사용자의 패스워드에 고유한 값을 추가하여 동일한 패스워드라도 ㅏ른 해시값잇 ㅐㅇ성되도록 합니다.\n\n4.\t세션 고정 공격: 로그아웃 후에도 세션이 완전히 무효화되지 않으므로, 세션 고정 공격의 가능성이 있습니다. 세션이 재생성되지 않으면 공격자가 기존의 세션 ID를 사용하여 계속 로그인 상태를 유지할 수 있습니다.\n\n5.\tCSRF 취약점: 이 코드에는 CSRF 방어 메커니즘이 포함되어 있지 않아, 사용자가 로그인한 상태에서 악의적입 쉡사이트가 사용자 대신 요청을 보내는 CSRF 공격에 취약할 수 있습니다.\n\n코드를 개선하기 위해서는, XSS 방지 및 세션 관리 강화, 그리고 CSRF 보호를 추가해야 합니다.\n",
          "problems": [
            {
              "question": "1. 이 코드에서 세션 관리와 관련된 보안 취약점은 무엇인가요?",
              "choices": ["세션을 암호화 하지 않음", "세션 쿠키에 Secure 플래그가 설정되지 않음", "세션 쿠키에 SameSite 플래그가 설정되지 않음", "위의 2,3 모두"],
              "correctAnswer": 3,
              "commentary": "세션 쿠키에 Secure 플래그와 SameSite 플래그가 설정되지 않으면, 세션 탈취(CSRF 공격 등) 및 중간자 공격의 위험이 있습니다. Secure는 HTTPS에서만 쿠키가 전송되도록 하고, SameSite는 쿠키가 다른 도메인에서 전송되는 것을 방지합니다."
            },

            {
              "question": "2. 이 코드에서 사용된 해시 함수는 보안상 적합한가요? 적합하다면 그 이유는 무엇일까요?",
              "choices": ["적합하지 않다. SHA-256은 해시만 처리하고, 솔트가 사용되지 않았다.", "적합하다. SHA-256은 충분히 안전한 해시 함수다.", "적합하지 않다. MD5 해시 함수는 더 안전하다.", "적합하지 않다. 해시 함수는 암호화와 다르기 때문에 취약하다."],
              "correctAnswer": 0,
              "commentary": "SHA-256은 안전한 해시 함수이지만, 솔트가 없으면 동일한 패스워드에 대해 동일한 해시 값이 생성되므로 레인보우 테이블 공격에 취약해질 수 있습니다. 패스워드를 안전하게 저장하려면 솔트 값을 추가해야 합니다."
            },

            {
              "question": "3. 이 코드에서 발생할 수 있는 보안 문제가 아닌 것은 무엇인가요?",
              "choices": ["크로스 사이트 요청 위조(CSRF)", "크로스 사이트 스크립팅(XSS)", "세션 하이재킹", "SQL 인젝션"],
              "correctAnswer": 3,
              "commentary": "이 코드에서는 데이터베이스 쿼리가 없기 때문에 SQL 인젝션은 발생하지 않습니다. 그러나 XSS, 세션 하이재킹, CSRF 공격은 발생할 수 있습니다."
            },

            {
              "question": "4. 이 코드에서 세션 쿠키의 설정 중, 공격자가 자바스크립트를 이용해 쿠키에 접근하지 못하게 하기 위해 추가해야 할 것은 무엇인가요?",
              "choices": ["Secure", "HttpOnly", "SameSite", "Domain"],
              "correctAnswer": 1,
              "commentary": "HttpOnly 플래그는 쿠키를 자바스크립트에서 접근하지 못하도록 방지합니다. 이를 통해 XSS 공격으로 쿠키 정보가 탈취되는 것을 막을 수 있습니다. Secure와 SameSite는 다른 종류의 공격 방어에 도움이 되지만, 쿠키를 자바스크립트로부터 보호하는 것은 HttpOnly 플래그입니다."
            },

            {
              "question": "5. 다음 중 이 코드에서 CSRF(Cross-Site Request Forgery) 공격을 방지하는 방법은 무엇인가요?",
              "choices": ["모든 POST 요청에 CSRF 토큰을 포함한다.", "GET 요청에서만 CSRF 방어를 적용한다.", "세션 ID를 암호화한다.", "모든 요청에 CAPTCHA를 적용한다."],
              "correctAnswer": 0,
              "commentary": "CSRF 공격을 방지하려면 POST 요청에 CSRF 토큰을 포함하는 것이 필수적입니다. CSRF 토큰은 서버가 클라이언트에 고유하게 발급하는 토큰으로, 요청 시 이 토큰이 유효한지 확인함으로써 공격을 방지할 수 있습니다. GET 요청에는 일반적으로 CSRF 방어가 필요하지 않지만, 민감한 요청일 경우 추가적인 검토가 필요할 수 있습니다."
            },

            {
              "question": "6. 이 코드에서 로그인 실패 시 어떤 보안 강화 조치를 추가할 수 있을까요?",
              "choices": ["패스워드를 암호화하지 않고 저장한다.", "로그인 시도를 제한하거나 지연시킨다.", "로그인 실패 시에도 동일한 오류 메시지를 표시하지 않는다.", "패스워드 대신 사용자 이름을 해시화하여 저장한다."],
              "correctAnswer": 1,
              "commentary": "로그인 실패 시 지속적인 시도를 방지하기 위해서는 로그인 시도 횟수를 제한하거나 시도 간격을 늘리는 방법을 사용해야 합니다. 이를 통해 브루트포스 공격을 방어할 수 있습니다."
            },

            {
              "question": "7. 로그인 성공 시 사용되는 session['username'] = username 코드가 어떤 위험을 초래할 수 있나요?",
              "choices": ["세션 ID가 노출될 수 있다.", "CSRF 공격에 취약해질 수 있다.", "사용자가 세션을 쉽게 조작할 수 있다.", "공격자가 세션 ID를 탈취할 수 있다."],
              "correctAnswer": 2,
              "commentary": "세션에 사용자의 민감한 데이터를 저장할 때는 적절한 보안 조치가 필요합니다. 만약 세션에 저장되는 데이터가 검증되지 않으면 사용자가 세션을 조작하여 불법적인 접근을 시도할 수있습니다. 중요한 데이터는 서버 측에서 검증해야 합니다."
            },

            {
              "question": "8. 코드에서 세션 하이재킹(Session Hijacking) 공격을 방어하는 가장 적절한 방법은 무엇인가요?",
              "choices": ["HTTPS를 사용하여 모든 통신을 암호화한다.", "세션 쿠키에 HttpOnly 플래그를 설정한다.", "세션 쿠키에 SameSite 플래그를 설정한다.", "위의 모든 방법을 사용한다."],
              "correctAnswer": 3,
              "commentary": "세션 하이재킹 공격을 방어하기 위해서는 다양한 보안 조치를 함께 사용해야 합니다. HTTPS는 네트워크 상에서 데이터를 암호화하여 중간자 공격을 방지하고, HttpOnly는 자바스크립트에서 쿠키에 접근하는 것을 방지하며, SameSite는 다른 도메인에서 세션 쿠키가 전송되는 것을 방지합니다."
            },

            {
              "question": "9. 이 코드는 로그인 세션을 어떻게 처리하고 있나요?",
              "choices": ["쿠키 기반 인증을 사용하여 세션을 유지한다.", "토큰 기반 인증을 사용하여 세션을 유지한다.", "세션을 사용하여 서버 측에서 상태를 저장한다.", "세션 없이 상태를 유지하지 않는다."],
              "correctAnswer": 2,
              "commentary": "이 코드는 Flask의 기본 세션 관리 기능을 사용하여 세션을 서버 측에서 유지합니다. 사용자가 로그인하면 session 객체에 사용자의 정보를 저장하고, 이를 통해 상태를 유지합니다."
            },

            {
              "question": "10. 이 코드에서 로그아웃 기능(logout() 함수)의 취약점은 무엇인가요?",
              "choices": ["세션 ID를 재생성하지 않는다.", "사용자를 완전히 로그아웃하지 않는다.", "세션 데이터를 클라이언트 측에 저장한다.", "로그아웃 시 강제 로그아웃이 적용되지 않는다."],
              "correctAnswer": 0,
              "commentary": "사용자가 로그아웃한 후에도 세션 ID가 변경되지 않으면, 공격자가 이전 세션 ID를 재사용하여 세션 고정 공격(Session Fixation)을 시도할 수 있습니다. 안전한 로그아웃을 위해 세션 ID를 재생성하는 것이 중요합니다."
            },

            {
              "question": "11. 검색 쿼리에서 XSS 공격을 방어하기 위해 가장 적합한 방법은 무엇인가요?",
              "choices": ["SQL 쿼리로 변환하기 전에 사용자 입력을 검증한다.", "사용자 입력을 HTML로 변환하기 전에 이스케이프 처리한다.", "입력된 데이터를 데이터베이스에 저장하기 전에 해시화한다.", "입력된 데이터를 로그에 기록하기 전에 암호화한다."],
              "correctAnswer": 1,
              "commentary": "XSS 공격을 방어하려면, 사용자 입력을 HTML로 렌더링하기 전에 이스케이프 처리를 해야 합니다. 이스케이프 처리를 통해 입력된 HTML 태그나 자바스크립트 코드를 무력화하여, 악의적인 코드가 실행되지 않도록 막을 수 있습니다."
            },

            {
              "question": "12. 이 코드에서 사용자 로그인 처리 후 리다이렉트를 수행하는 redirect() 함수에 대한 보안 문제는 무엇인가요?",
              "choices": ["리다이렉션 URL이 하드코딩되어 있다.", "사용자의 입력을 바탕으로 리다이렉트가 수행될 수 있다.", "리다이렉트 URL에 쿼리 파라미터가 포함되지 않는다.", "세션 데이터를 사용하지 않고 리다이렉트한다."],
              "correctAnswer": 1,
              "commentary": "만약 리다이렉트 URL이 사용자의 입력에 의해 결정된다면, 악의적인 사용자가 이를 악용하여 피싱 사이트로 유도하는 리다이렉션 공격(Open Redirect)이 발생할 수 있습니다. 리다이렉트 URL을 사용자의 입력에 의존하지 않도록 하는 것이 안전합니다."
            },

            {
              "question": "13. 사용자가 로그인에 실패할 경우 flash() 함수를 사용하여 오류 메시지를 표시하는데, 이는 어떤 보안 위험을 초래할 수 있나요?",
              "choices": ["패스워드 해싱이 실패할 수 있다.", "세션 고정 공격을 야기할 수 있다.", "과도한 정보 제공으로 인한 공격을 유발할 수 있다.", "CSRF 공격을 가능하게 한다."],
              "correctAnswer": 2,
              "commentary": "로그인 실패 시 너무 구체적인 오류 메시지를 제공하면, 공격자가 어떤 부분이 잘못되었는지 알아낼 수 있어 브루트포스 공격을 시도하는 데 도움이 됩니다. 일반적인 \"로그인 실패\"와 같은 메시지를 제공하는 것이 바람직합니다."
            }
          ]
        }

      ]
    },

    {
      "subpage": 3,
      "levels": [
        {
          "level": 1,
          "images": ["level1_hard_img1", "level1_hard_img2","level1_hard_img3","level1_hard_img4","level1_hard_img5","level1_hard_img6"],
          "codeBox":"3-4번째 이미지 코드 해설: \n\n1.\tsub rsp, 0x30는 스택에서 48바이트(0x30) 공간을 할당합니다. 이 중 rbp-0x20와 rbp-0x30 위치에 id[]와 pass[] 배열이 저장됩니다.\n\n2.\tid[]는 rbp-0x20에 저장되고, pass[]는 rbp-0x30에 저장되므로 각각 16바이트 할당을 받습니다. \n\n3.\tgetchar()로 사용자 입력을 받으며, id[]에 입력된 값을 저장하는 루프에서 입력된 값은 rbp-0x20부터 저장됩니다.\n\n4.\tpass[]의 입력 값은 rbp-0x30부터 저장되며, 두 배열의 크기가 초과될 경우 스택의 다른 변수나 리턴 주소를 덮어쓸 수 있습니다.\n\n5.\tid[] 배열에 저장하는 부분:\n-\t0x00005555555551a3 <+58>: mov BYTE PTR [rbp+rax*1-0x20], dl\n이 명령어는 getchar()로 읽어온 값을 id[] 배열에 저장하는 부분입니다. id[]는 16바이트로 제한되어 있지만, 경계 체크 없이 i가 계속 증가하면 16바이트 이상을 저장하려고 하면서 스택 메모리를 침범하게 됩니다.\n\n6.\tPass[] 배열에 저장하는 부분:\n-\t0x00005555555551e8 <+127>: mov BYTE PTR [rbp+rax*1-0x30], dl\n이 명령어는 pass[]에 값을 저장하는 부분입니다. 마찬가지로 pass[]도 16바이트만 할당받았지만, 사용자로부터 받은 데이터가 16바이트를 넘으면 스택 상의 다른 중요한 데이터를 덮어쓸 수 있습니다.\n\n\n\n 5-6번째 이미지 코드 해설: \n\n(5번째 이미지)\n User ID 입력에서 a를 6번 입력\n\n(6번째 이미지)\n a를 17번 입력\n\n- 0x7ff~~fd330을 침범 (16바이트를 넘음)\n\n * Main+58에 break 포인트 걸고 입력한 글자만큼 반복문을 돌리면 다음으로 넘어 감 (한 바퀴 돌때마다 61이 생김)\n\n - 6개를 입력하면 6번 째에 다른 코드로 넘어 감\n\n",
          "problems": [
            {
              "question": "1. 첫 번째 이미지의 코드에선 어떤 취약점이 보이나요?",
              "choices": ["Memory Leak", "Security Misconfiguration", "Buffer overflow", "Privilege Escalation"],
              "correctAnswer": 2,
              "commentary": "?"
            },

            {
              "question": "2. 첫 번째 이미지의 코드에서 id와 pass 배열에 버퍼 오버플로우가 발생할 수 있는 이유는 무엇인가요?",
              "choices": ["배열의 크기보다 긴 입력을 처리할 수 있기 때문이다.", "Getchar()함수가 입력을 무한히 받기 때문이다.", "배열의 크기가 적절히 설정되어 있기 떄문이다.", "입력이 항상 개행문자로 끝나기 때문이다."],
              "correctAnswer": 0,
              "commentary": "코드에서 id[16]과 pass[16] 배열은 각각 16바이트의 크기를 갖는다. 만약 입력된 문자열이 배열의 크기를 넘어서면, 배열 경계를 넘는 데이터가 메모리에 저장되며, 이로 인해 버퍼 오버플로우가 발생할 수 있다."
            },

            {
              "question": "3. 어셈블리 코드에서 버퍼 오버플로우 취약점이 발생할 가능성이 가장 높은 명령어의 주소는 무엇인가요?",
              "choices": ["0x000055555555518a", "0x00005555555551a3", "0x00005555555551dc", "0x000055555555520c"],
              "correctAnswer": 1,
              "commentary": "주소 0x00005555555551a3에 위치한 명령어는mov Byte PTR [rbp+rax*1-0x20],dl인데 이 명령어는 사용자 입력을 버퍼에 저장하는 작업을 수행한다. 이 명령어 이전에 getchar@plt함수 호출이 있어, 사용자로부터 입력을 받는데 코드에서는 버퍼의 크기를 체크하는 부분이 보이지 않는다. 따라서 사용자가 예상된 크기보다 더 많은 데이터를 입력하면 이 부분에서 버퍼 오버 플로우가 발생한다."
            }
          ]
        },

        {
          "level": 2,
          "images": ["level2_hard_img1", "level2_hard_img2","level2_hard_img3","level2_hard_img4"],
          "codebox":"",
          "problems": [
            {
              "question": "1. AssignmentOutput 함수의 주요 목적이 무엇인가요?",
              "choices": ["메모리를 할당하고, 사용자 입력을 복사한 후 출력한다.", "사용자 입력을 스캔하고 입력의 길이를 반환한다.", "메모리를 할당하고 입력 문자열을 역순으로 바꾼 후 출력한다.", "사용자 입력을 읽고 아무 동작 없이 종료한다."],
              "correctAnswer": 0,
              "commentary": "malloc을 사용해 버퍼를 할당하고 strncpy로 사용자 입력을 복사한 뒤, buf[99]에 널 문자를 추가하고 버퍼를 출력한다, 마지막으로 할당된 메모리를 free 로 해제힌다."
            },

            {
              "question": "2. AssignmentOutput 함수에서 메모리 할당이 실패할 경우(malloc이 NULL을 반환하는 경우) 어떻게 되나요?",
              "choices": ["프로그램이 Failed을 출력하고 계속 실행된다.", "프로그램이 메시지 없이 종료된다.", "프로그램이 Failed를 출력하고 종료된다.", "프로그램이 세그멘테이션 폴트를 발생시킨다."],
              "correctAnswer": 2,
              "commentary": "c 코드에서 malloc이 NULL을 반환하면 프로그램은 printf로 Failed 메시지를 출력한 후 exit(1)을 호출해 프로그램을 종효함. 어셈블리어에서도 puts@plt와 exit@plt 호출이 확인되며, 메모리 할당 실패 시 프로그램이 종료되는 것을 알 수 있다."
            },

            {
              "question": "3. C 소스코드에서 발생할 수 있는 취약점과 그 원인은 무엇인가요?",
              "choices": ["Malloc 사용 후 메모리를 해제하지 않아 메모리 누수가 발생한다.", "Printf에서 형식 지정자가 사용되지 않아 Format String Bug가 발생할 수 있다.", "입력 크기를 제한하지 않아 버퍼 오버플로우가 발생할 수 있다.", "메모리 할당에 실패했을 때 적절한 오류 처리가 이루어지지 않는다."],
              "correctAnswer": 1,
              "commentary": "코드에서 Format String Bug가 발생할 가능성이 있다. Printf(buf); 는 사용자로부터 입력받은 데이터를 그대로 출력하는데 이때 형식 지정자를 지정하지 않아, 만약 사용자가 %p, %x, %n 등의 형식 지정자를 포함시킨다면, printf가 이를 해석하려고 시도하면서 메모리 접근이나 조작을 할 수 있게 된다."
            }
          ]
        },

        {
          "level": 3,
          "images": ["level3_hard_img1", "level3_hard_img2","level3_hard_img3_1","level3_hard_img5"],
          "codeBox": "이 코드는 기본적인 웹 애플리케이션을 구성하고 있으며, 로그인, 로그아웃, 세션 관리, 그리고 사용자 입력을 처리하는 검색 기능을 제공합니다. 그러나 보안 측면에서 여러 가지 취약점이 존재합니다.\n\n1.\t세션 관리 취약점: 세션 쿠키에 Secure와 SameSite 플래그가 설정되지 않아 세션 탈취(CSRF 공격 등) 및 중간자 공격의 위험이 있습니다.\n\n2.\tXSS 취약점: 검색 기능에서 사용자 입력을 HRML로 직접 출력하는 방식으로 처리하고 있어 크로스 사이트 스크립팅(XSS)공격에 취약합니다. 악의적인 사용자가 자바스크립트 코드를 삽입할 수 있습니다.\n\n3.\tSHA-256 사용의 문제점: SHA-256은 안전한 해시 함수이지만, 패스워드 해싱에 솔트를 사용하지 않으면 레인보우 테이블 공격에 취약합니다. 솔트는 각 사용자의 패스워드에 고유한 값을 추가하여 동일한 패스워드라도 다른 해시값이 생성되도록 합니다.\n\n4.\t세션 고정 공격: 로그아웃 후에도 세션이 완전히 무효화되지 않으므로, 세션 고정 공격의 가능성이 있습니다. 세션이 재생성되지 않으면 공격자가 기존의 세션 ID를 사용하여 계속 로그인 상태를 유지할 수 있습니다.\n\n5.\tCSRF 취약점: 이 코드에는 CSRF 방어 메커니즘이 포함되어 있지 않아, 사용자가 로그인한 상태에서 악의적입 쉡사이트가 사용자 대신 요청을 보내는 CSRF 공격에 취약할 수 있습니다.\n\n코드를 개선하기 위해서는, XSS 방지 및 세션 관리 강화, 그리고 CSRF 보호를 추가해야 합니다.\n",
          "problems": [
            {
              "question": "1. 해당 이미지의 코드는 무슨 공격을 하는 화면인가요?",
              "choices": ["SQL 인젝션", "MITM", "LFI", "SSRF"],
              "correctAnswer": 0,
              "commentary": "?"
            },

            {
              "question": "2. 이메일 형식 검증을 하지 않도록 만들기 위해 type=“?” 의 ?에는 무엇이 들어가야 하나요?",
              "choices": ["id", "email", "text", "Letter"],
              "correctAnswer": 2,
              "commentary": "?"
            },

            {
              "question": "3. 세 번째 이미지의 코드에서 사용된 인증 방식의 주요 문제점은 무엇인가요?",
              "choices": ["세션 관리가 부적절하게 이루어지고 있다.", "비밀번호 해싱이 이루어지지 않고 있다.", "HTTPS를 강제하지 않고 있다.", "다중 요소 인증(MFA)을 지원하지 않는다."],
              "correctAnswer": 1,
              "commentary": "세번 째 이미지의 코드에서는 비밀번호를 평문 그대로 데이터베이스와 비교하고 있음. 이는 매우 위험한 방식으로, 다음과 같은 심각한 보안 문제를 야기할 수 있다:\n데이터베이스가 해킹당할 경우, 모든 사용자의 실제 비밀번호가 노출.\n내부자가 쉽게 사용자의 비밀번호를 볼 수 있다.\n동일한 비밀번호를 사용하는 다른 서비스도 위험에 노출될 수 있다.\n올바른 방식은 비밀번호를 안전한 해시 함수(예: bcrypt, Argon2)를 사용하여 해시한 후 저장하고, 로그인 시 입력된 비밀번호의 해시값과 저장된 해시값을 비교하는 것이다.\n다른 보기들도 보안을 강화하는 데 중요한 요소들이지만, 비밀번호 해싱의 부재만큼 근본적이고 심각한 문제는 아니다."
            }
          ]
        },

        {
          "level": 4,
          "images": ["level4_hard_img1", "level4_hard_img2","level4_hard_img3","level4_hard_img4"],
          "codebox": "",
          "problems": [
            {
              "question": "1. 위 이미지는 XSS의 한 종류입니다. 무슨 형태의 XSS인가요?",
              "choices": ["Mutated XSS", "DOM-based XSS", "Stored XSS", "Reflected XSS"],
              "correctAnswer": 3,
              "commentary": "?"
            },

            {
              "question": "2. Reflected XSS란 무엇인가요?",
              "choices": ["사용자가 입력한 데이터가 서버에서 검증되지 않고 페이지에 반영되는 공격이다.", "사용자가 서버에 악성 코드를 업로드하는 공격이다.", "서버에 저장된 데이터를 변조하는 공격이다.", "사용자가 다른 사용자의 세션을 탈취하는 공격이다."],
              "correctAnswer": 0,
              "commentary": "?"
            },

            {
              "question": "3. XSS 공격을 통해 공격자가 얻을 수 있는 정보는 무엇인가요?",
              "choices": ["사용자 이름과 비밀번호", "서버의 소스 코드", "데이터베이스의 구조", "사용자의 브라우저 히스토리"],
              "correctAnswer": 0,
              "commentary": "?"
            }
          ]
        }

      ]
    }

  ]
}
